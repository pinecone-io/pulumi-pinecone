# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CollectionTimeoutsArgs',
    'CollectionTimeoutsArgsDict',
    'IndexEmbedArgs',
    'IndexEmbedArgsDict',
    'IndexSpecArgs',
    'IndexSpecArgsDict',
    'IndexSpecPodArgs',
    'IndexSpecPodArgsDict',
    'IndexSpecPodMetadataConfigArgs',
    'IndexSpecPodMetadataConfigArgsDict',
    'IndexSpecServerlessArgs',
    'IndexSpecServerlessArgsDict',
    'IndexStatusArgs',
    'IndexStatusArgsDict',
    'IndexTimeoutsArgs',
    'IndexTimeoutsArgsDict',
    'GetEmbedArgs',
    'GetEmbedArgsDict',
    'GetSpecArgs',
    'GetSpecArgsDict',
    'GetSpecPodArgs',
    'GetSpecPodArgsDict',
    'GetSpecPodMetadataConfigArgs',
    'GetSpecPodMetadataConfigArgsDict',
    'GetSpecServerlessArgs',
    'GetSpecServerlessArgsDict',
    'GetStatusArgs',
    'GetStatusArgsDict',
]

MYPY = False

if not MYPY:
    class CollectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CollectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class IndexEmbedArgsDict(TypedDict):
        dimension: NotRequired[pulumi.Input[_builtins.int]]
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        field_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        the name of the embedding model to use for the index.
        """
        read_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The read parameters for the embedding model.
        """
        vector_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        write_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The write parameters for the embedding model.
        """
elif False:
    IndexEmbedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexEmbedArgs:
    def __init__(__self__, *,
                 dimension: Optional[pulumi.Input[_builtins.int]] = None,
                 field_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 read_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 vector_type: Optional[pulumi.Input[_builtins.str]] = None,
                 write_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] dimension: The dimension of the embedding model, specifying the size of the output vector.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] field_map: Identifies the name of the text field from your document model that will be embedded.
        :param pulumi.Input[_builtins.str] metric: The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        :param pulumi.Input[_builtins.str] model: the name of the embedding model to use for the index.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] read_parameters: The read parameters for the embedding model.
        :param pulumi.Input[_builtins.str] vector_type: The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] write_parameters: The write parameters for the embedding model.
        """
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if field_map is not None:
            pulumi.set(__self__, "field_map", field_map)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if read_parameters is not None:
            pulumi.set(__self__, "read_parameters", read_parameters)
        if vector_type is not None:
            pulumi.set(__self__, "vector_type", vector_type)
        if write_parameters is not None:
            pulumi.set(__self__, "write_parameters", write_parameters)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="fieldMap")
    def field_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        return pulumi.get(self, "field_map")

    @field_map.setter
    def field_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "field_map", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the name of the embedding model to use for the index.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="readParameters")
    def read_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The read parameters for the embedding model.
        """
        return pulumi.get(self, "read_parameters")

    @read_parameters.setter
    def read_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "read_parameters", value)

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        return pulumi.get(self, "vector_type")

    @vector_type.setter
    def vector_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vector_type", value)

    @_builtins.property
    @pulumi.getter(name="writeParameters")
    def write_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The write parameters for the embedding model.
        """
        return pulumi.get(self, "write_parameters")

    @write_parameters.setter
    def write_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "write_parameters", value)


if not MYPY:
    class IndexSpecArgsDict(TypedDict):
        pod: NotRequired[pulumi.Input['IndexSpecPodArgsDict']]
        """
        Configuration needed to deploy a pod-based index.
        """
        serverless: NotRequired[pulumi.Input['IndexSpecServerlessArgsDict']]
        """
        Configuration needed to deploy a serverless index.
        """
elif False:
    IndexSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexSpecArgs:
    def __init__(__self__, *,
                 pod: Optional[pulumi.Input['IndexSpecPodArgs']] = None,
                 serverless: Optional[pulumi.Input['IndexSpecServerlessArgs']] = None):
        """
        :param pulumi.Input['IndexSpecPodArgs'] pod: Configuration needed to deploy a pod-based index.
        :param pulumi.Input['IndexSpecServerlessArgs'] serverless: Configuration needed to deploy a serverless index.
        """
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)

    @_builtins.property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['IndexSpecPodArgs']]:
        """
        Configuration needed to deploy a pod-based index.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['IndexSpecPodArgs']]):
        pulumi.set(self, "pod", value)

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> Optional[pulumi.Input['IndexSpecServerlessArgs']]:
        """
        Configuration needed to deploy a serverless index.
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: Optional[pulumi.Input['IndexSpecServerlessArgs']]):
        pulumi.set(self, "serverless", value)


if not MYPY:
    class IndexSpecPodArgsDict(TypedDict):
        environment: pulumi.Input[_builtins.str]
        """
        The environment where the index is hosted.
        """
        pod_type: pulumi.Input[_builtins.str]
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        metadata_config: NotRequired[pulumi.Input['IndexSpecPodMetadataConfigArgsDict']]
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        pods: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        shards: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        source_collection: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the collection to create an index from.
        """
elif False:
    IndexSpecPodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexSpecPodArgs:
    def __init__(__self__, *,
                 environment: pulumi.Input[_builtins.str],
                 pod_type: pulumi.Input[_builtins.str],
                 metadata_config: Optional[pulumi.Input['IndexSpecPodMetadataConfigArgs']] = None,
                 pods: Optional[pulumi.Input[_builtins.int]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 shards: Optional[pulumi.Input[_builtins.int]] = None,
                 source_collection: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] environment: The environment where the index is hosted.
        :param pulumi.Input[_builtins.str] pod_type: The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        :param pulumi.Input['IndexSpecPodMetadataConfigArgs'] metadata_config: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        :param pulumi.Input[_builtins.int] pods: The number of pods to be used in the index. This should be equal to shards x replicas.'
        :param pulumi.Input[_builtins.int] replicas: The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        :param pulumi.Input[_builtins.int] shards: The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        :param pulumi.Input[_builtins.str] source_collection: The name of the collection to create an index from.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "pod_type", pod_type)
        if metadata_config is not None:
            pulumi.set(__self__, "metadata_config", metadata_config)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if source_collection is not None:
            pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> pulumi.Input[_builtins.str]:
        """
        The environment where the index is hosted.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter(name="podType")
    def pod_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        return pulumi.get(self, "pod_type")

    @pod_type.setter
    def pod_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pod_type", value)

    @_builtins.property
    @pulumi.getter(name="metadataConfig")
    def metadata_config(self) -> Optional[pulumi.Input['IndexSpecPodMetadataConfigArgs']]:
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        return pulumi.get(self, "metadata_config")

    @metadata_config.setter
    def metadata_config(self, value: Optional[pulumi.Input['IndexSpecPodMetadataConfigArgs']]):
        pulumi.set(self, "metadata_config", value)

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pods", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)

    @_builtins.property
    @pulumi.getter
    def shards(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        return pulumi.get(self, "shards")

    @shards.setter
    def shards(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "shards", value)

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the collection to create an index from.
        """
        return pulumi.get(self, "source_collection")

    @source_collection.setter
    def source_collection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_collection", value)


if not MYPY:
    class IndexSpecPodMetadataConfigArgsDict(TypedDict):
        indexeds: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The indexed fields.
        """
elif False:
    IndexSpecPodMetadataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexSpecPodMetadataConfigArgs:
    def __init__(__self__, *,
                 indexeds: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] indexeds: The indexed fields.
        """
        pulumi.set(__self__, "indexeds", indexeds)

    @_builtins.property
    @pulumi.getter
    def indexeds(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The indexed fields.
        """
        return pulumi.get(self, "indexeds")

    @indexeds.setter
    def indexeds(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "indexeds", value)


if not MYPY:
    class IndexSpecServerlessArgsDict(TypedDict):
        cloud: pulumi.Input[_builtins.str]
        """
        The public cloud where you would like your index hosted. [gcp|aws|azure]
        """
        region: pulumi.Input[_builtins.str]
        """
        The region where you would like your index to be created.
        """
elif False:
    IndexSpecServerlessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexSpecServerlessArgs:
    def __init__(__self__, *,
                 cloud: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cloud: The public cloud where you would like your index hosted. [gcp|aws|azure]
        :param pulumi.Input[_builtins.str] region: The region where you would like your index to be created.
        """
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> pulumi.Input[_builtins.str]:
        """
        The public cloud where you would like your index hosted. [gcp|aws|azure]
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The region where you would like your index to be created.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class IndexStatusArgsDict(TypedDict):
        ready: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ready.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
elif False:
    IndexStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexStatusArgs:
    def __init__(__self__, *,
                 ready: Optional[pulumi.Input[_builtins.bool]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] ready: Ready.
        :param pulumi.Input[_builtins.str] state: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        if ready is not None:
            pulumi.set(__self__, "ready", ready)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def ready(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ready.
        """
        return pulumi.get(self, "ready")

    @ready.setter
    def ready(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ready", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class IndexTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    IndexTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GetEmbedArgsDict(TypedDict):
        dimension: _builtins.int
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        field_map: Mapping[str, _builtins.str]
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        metric: _builtins.str
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        model: _builtins.str
        """
        the name of the embedding model to use for the index.
        """
        read_parameters: Mapping[str, _builtins.str]
        """
        The read parameters for the embedding model.
        """
        vector_type: _builtins.str
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        write_parameters: Mapping[str, _builtins.str]
        """
        The write parameters for the embedding model.
        """
elif False:
    GetEmbedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmbedArgs:
    def __init__(__self__, *,
                 dimension: _builtins.int,
                 field_map: Mapping[str, _builtins.str],
                 metric: _builtins.str,
                 model: _builtins.str,
                 read_parameters: Mapping[str, _builtins.str],
                 vector_type: _builtins.str,
                 write_parameters: Mapping[str, _builtins.str]):
        """
        :param _builtins.int dimension: The dimension of the embedding model, specifying the size of the output vector.
        :param Mapping[str, _builtins.str] field_map: Identifies the name of the text field from your document model that will be embedded.
        :param _builtins.str metric: The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        :param _builtins.str model: the name of the embedding model to use for the index.
        :param Mapping[str, _builtins.str] read_parameters: The read parameters for the embedding model.
        :param _builtins.str vector_type: The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        :param Mapping[str, _builtins.str] write_parameters: The write parameters for the embedding model.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "field_map", field_map)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "read_parameters", read_parameters)
        pulumi.set(__self__, "vector_type", vector_type)
        pulumi.set(__self__, "write_parameters", write_parameters)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.int:
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: _builtins.int):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="fieldMap")
    def field_map(self) -> Mapping[str, _builtins.str]:
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        return pulumi.get(self, "field_map")

    @field_map.setter
    def field_map(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "field_map", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: _builtins.str):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        the name of the embedding model to use for the index.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: _builtins.str):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="readParameters")
    def read_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The read parameters for the embedding model.
        """
        return pulumi.get(self, "read_parameters")

    @read_parameters.setter
    def read_parameters(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "read_parameters", value)

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> _builtins.str:
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        return pulumi.get(self, "vector_type")

    @vector_type.setter
    def vector_type(self, value: _builtins.str):
        pulumi.set(self, "vector_type", value)

    @_builtins.property
    @pulumi.getter(name="writeParameters")
    def write_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The write parameters for the embedding model.
        """
        return pulumi.get(self, "write_parameters")

    @write_parameters.setter
    def write_parameters(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "write_parameters", value)


if not MYPY:
    class GetSpecArgsDict(TypedDict):
        pod: 'GetSpecPodArgsDict'
        """
        Configuration needed to deploy a pod-based index.
        """
        serverless: 'GetSpecServerlessArgsDict'
        """
        Configuration needed to deploy a serverless index.
        """
elif False:
    GetSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpecArgs:
    def __init__(__self__, *,
                 pod: 'GetSpecPodArgs',
                 serverless: 'GetSpecServerlessArgs'):
        """
        :param 'GetSpecPodArgs' pod: Configuration needed to deploy a pod-based index.
        :param 'GetSpecServerlessArgs' serverless: Configuration needed to deploy a serverless index.
        """
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "serverless", serverless)

    @_builtins.property
    @pulumi.getter
    def pod(self) -> 'GetSpecPodArgs':
        """
        Configuration needed to deploy a pod-based index.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: 'GetSpecPodArgs'):
        pulumi.set(self, "pod", value)

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> 'GetSpecServerlessArgs':
        """
        Configuration needed to deploy a serverless index.
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: 'GetSpecServerlessArgs'):
        pulumi.set(self, "serverless", value)


if not MYPY:
    class GetSpecPodArgsDict(TypedDict):
        environment: _builtins.str
        """
        The environment where the index is hosted.
        """
        metadata_config: 'GetSpecPodMetadataConfigArgsDict'
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        pod_type: _builtins.str
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        pods: _builtins.int
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        replicas: _builtins.int
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        shards: _builtins.int
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        source_collection: _builtins.str
        """
        The name of the collection to create an index from.
        """
elif False:
    GetSpecPodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpecPodArgs:
    def __init__(__self__, *,
                 environment: _builtins.str,
                 metadata_config: 'GetSpecPodMetadataConfigArgs',
                 pod_type: _builtins.str,
                 pods: _builtins.int,
                 replicas: _builtins.int,
                 shards: _builtins.int,
                 source_collection: _builtins.str):
        """
        :param _builtins.str environment: The environment where the index is hosted.
        :param 'GetSpecPodMetadataConfigArgs' metadata_config: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        :param _builtins.str pod_type: The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        :param _builtins.int pods: The number of pods to be used in the index. This should be equal to shards x replicas.'
        :param _builtins.int replicas: The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        :param _builtins.int shards: The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        :param _builtins.str source_collection: The name of the collection to create an index from.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "metadata_config", metadata_config)
        pulumi.set(__self__, "pod_type", pod_type)
        pulumi.set(__self__, "pods", pods)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "shards", shards)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment where the index is hosted.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: _builtins.str):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter(name="metadataConfig")
    def metadata_config(self) -> 'GetSpecPodMetadataConfigArgs':
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        return pulumi.get(self, "metadata_config")

    @metadata_config.setter
    def metadata_config(self, value: 'GetSpecPodMetadataConfigArgs'):
        pulumi.set(self, "metadata_config", value)

    @_builtins.property
    @pulumi.getter(name="podType")
    def pod_type(self) -> _builtins.str:
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        return pulumi.get(self, "pod_type")

    @pod_type.setter
    def pod_type(self, value: _builtins.str):
        pulumi.set(self, "pod_type", value)

    @_builtins.property
    @pulumi.getter
    def pods(self) -> _builtins.int:
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: _builtins.int):
        pulumi.set(self, "pods", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: _builtins.int):
        pulumi.set(self, "replicas", value)

    @_builtins.property
    @pulumi.getter
    def shards(self) -> _builtins.int:
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        return pulumi.get(self, "shards")

    @shards.setter
    def shards(self, value: _builtins.int):
        pulumi.set(self, "shards", value)

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        """
        The name of the collection to create an index from.
        """
        return pulumi.get(self, "source_collection")

    @source_collection.setter
    def source_collection(self, value: _builtins.str):
        pulumi.set(self, "source_collection", value)


if not MYPY:
    class GetSpecPodMetadataConfigArgsDict(TypedDict):
        indexeds: Sequence[_builtins.str]
        """
        The indexed fields.
        """
elif False:
    GetSpecPodMetadataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpecPodMetadataConfigArgs:
    def __init__(__self__, *,
                 indexeds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] indexeds: The indexed fields.
        """
        pulumi.set(__self__, "indexeds", indexeds)

    @_builtins.property
    @pulumi.getter
    def indexeds(self) -> Sequence[_builtins.str]:
        """
        The indexed fields.
        """
        return pulumi.get(self, "indexeds")

    @indexeds.setter
    def indexeds(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "indexeds", value)


if not MYPY:
    class GetSpecServerlessArgsDict(TypedDict):
        cloud: _builtins.str
        """
        Ready.
        """
        region: _builtins.str
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
elif False:
    GetSpecServerlessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpecServerlessArgs:
    def __init__(__self__, *,
                 cloud: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud: Ready.
        :param _builtins.str region: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        """
        Ready.
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: _builtins.str):
        pulumi.set(self, "cloud", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: _builtins.str):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetStatusArgsDict(TypedDict):
        ready: _builtins.bool
        """
        Ready.
        """
        state: _builtins.str
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
elif False:
    GetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStatusArgs:
    def __init__(__self__, *,
                 ready: _builtins.bool,
                 state: _builtins.str):
        """
        :param _builtins.bool ready: Ready.
        :param _builtins.str state: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "ready", ready)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def ready(self) -> _builtins.bool:
        """
        Ready.
        """
        return pulumi.get(self, "ready")

    @ready.setter
    def ready(self, value: _builtins.bool):
        pulumi.set(self, "ready", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: _builtins.str):
        pulumi.set(self, "state", value)


