# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'CollectionTimeouts',
    'IndexEmbed',
    'IndexSpec',
    'IndexSpecPod',
    'IndexSpecPodMetadataConfig',
    'IndexSpecServerless',
    'IndexStatus',
    'IndexTimeouts',
    'GetCollectionsCollectionResult',
    'GetEmbedResult',
    'GetEsIndexResult',
    'GetEsIndexEmbedResult',
    'GetEsIndexSpecResult',
    'GetEsIndexSpecPodResult',
    'GetEsIndexSpecPodMetadataConfigResult',
    'GetEsIndexSpecServerlessResult',
    'GetEsIndexStatusResult',
    'GetSpecResult',
    'GetSpecPodResult',
    'GetSpecPodMetadataConfigResult',
    'GetSpecServerlessResult',
    'GetStatusResult',
]

@pulumi.output_type
class CollectionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class IndexEmbed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldMap":
            suggest = "field_map"
        elif key == "readParameters":
            suggest = "read_parameters"
        elif key == "vectorType":
            suggest = "vector_type"
        elif key == "writeParameters":
            suggest = "write_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexEmbed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexEmbed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexEmbed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: Optional[_builtins.int] = None,
                 field_map: Optional[Mapping[str, _builtins.str]] = None,
                 metric: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 read_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 vector_type: Optional[_builtins.str] = None,
                 write_parameters: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int dimension: The dimension of the embedding model, specifying the size of the output vector.
        :param Mapping[str, _builtins.str] field_map: Identifies the name of the text field from your document model that will be embedded.
        :param _builtins.str metric: The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        :param _builtins.str model: the name of the embedding model to use for the index.
        :param Mapping[str, _builtins.str] read_parameters: The read parameters for the embedding model.
        :param _builtins.str vector_type: The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        :param Mapping[str, _builtins.str] write_parameters: The write parameters for the embedding model.
        """
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if field_map is not None:
            pulumi.set(__self__, "field_map", field_map)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if read_parameters is not None:
            pulumi.set(__self__, "read_parameters", read_parameters)
        if vector_type is not None:
            pulumi.set(__self__, "vector_type", vector_type)
        if write_parameters is not None:
            pulumi.set(__self__, "write_parameters", write_parameters)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.int]:
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="fieldMap")
    def field_map(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        return pulumi.get(self, "field_map")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.str]:
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        the name of the embedding model to use for the index.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="readParameters")
    def read_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The read parameters for the embedding model.
        """
        return pulumi.get(self, "read_parameters")

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> Optional[_builtins.str]:
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        return pulumi.get(self, "vector_type")

    @_builtins.property
    @pulumi.getter(name="writeParameters")
    def write_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The write parameters for the embedding model.
        """
        return pulumi.get(self, "write_parameters")


@pulumi.output_type
class IndexSpec(dict):
    def __init__(__self__, *,
                 pod: Optional['outputs.IndexSpecPod'] = None,
                 serverless: Optional['outputs.IndexSpecServerless'] = None):
        """
        :param 'IndexSpecPodArgs' pod: Configuration needed to deploy a pod-based index.
        :param 'IndexSpecServerlessArgs' serverless: Configuration needed to deploy a serverless index.
        """
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)

    @_builtins.property
    @pulumi.getter
    def pod(self) -> Optional['outputs.IndexSpecPod']:
        """
        Configuration needed to deploy a pod-based index.
        """
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> Optional['outputs.IndexSpecServerless']:
        """
        Configuration needed to deploy a serverless index.
        """
        return pulumi.get(self, "serverless")


@pulumi.output_type
class IndexSpecPod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podType":
            suggest = "pod_type"
        elif key == "metadataConfig":
            suggest = "metadata_config"
        elif key == "sourceCollection":
            suggest = "source_collection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexSpecPod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexSpecPod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexSpecPod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment: _builtins.str,
                 pod_type: _builtins.str,
                 metadata_config: Optional['outputs.IndexSpecPodMetadataConfig'] = None,
                 pods: Optional[_builtins.int] = None,
                 replicas: Optional[_builtins.int] = None,
                 shards: Optional[_builtins.int] = None,
                 source_collection: Optional[_builtins.str] = None):
        """
        :param _builtins.str environment: The environment where the index is hosted.
        :param _builtins.str pod_type: The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        :param 'IndexSpecPodMetadataConfigArgs' metadata_config: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        :param _builtins.int pods: The number of pods to be used in the index. This should be equal to shards x replicas.'
        :param _builtins.int replicas: The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        :param _builtins.int shards: The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        :param _builtins.str source_collection: The name of the collection to create an index from.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "pod_type", pod_type)
        if metadata_config is not None:
            pulumi.set(__self__, "metadata_config", metadata_config)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if source_collection is not None:
            pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment where the index is hosted.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="podType")
    def pod_type(self) -> _builtins.str:
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        return pulumi.get(self, "pod_type")

    @_builtins.property
    @pulumi.getter(name="metadataConfig")
    def metadata_config(self) -> Optional['outputs.IndexSpecPodMetadataConfig']:
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        return pulumi.get(self, "metadata_config")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.int]:
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def shards(self) -> Optional[_builtins.int]:
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        return pulumi.get(self, "shards")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> Optional[_builtins.str]:
        """
        The name of the collection to create an index from.
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class IndexSpecPodMetadataConfig(dict):
    def __init__(__self__, *,
                 indexeds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] indexeds: The indexed fields.
        """
        pulumi.set(__self__, "indexeds", indexeds)

    @_builtins.property
    @pulumi.getter
    def indexeds(self) -> Sequence[_builtins.str]:
        """
        The indexed fields.
        """
        return pulumi.get(self, "indexeds")


@pulumi.output_type
class IndexSpecServerless(dict):
    def __init__(__self__, *,
                 cloud: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud: The public cloud where you would like your index hosted. [gcp|aws|azure]
        :param _builtins.str region: The region where you would like your index to be created.
        """
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        """
        The public cloud where you would like your index hosted. [gcp|aws|azure]
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region where you would like your index to be created.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class IndexStatus(dict):
    def __init__(__self__, *,
                 ready: Optional[_builtins.bool] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.bool ready: Ready.
        :param _builtins.str state: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        if ready is not None:
            pulumi.set(__self__, "ready", ready)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def ready(self) -> Optional[_builtins.bool]:
        """
        Ready.
        """
        return pulumi.get(self, "ready")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class IndexTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        Timeout defaults to 5 mins. Accepts a string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class GetCollectionsCollectionResult(dict):
    def __init__(__self__, *,
                 dimension: _builtins.int,
                 environment: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int,
                 status: _builtins.str,
                 vector_count: _builtins.int):
        """
        :param _builtins.int dimension: The dimension of the vectors stored in each record held in the collection.
        :param _builtins.str environment: The environment where the collection is hosted.
        :param _builtins.str name: The name of the collection.
        :param _builtins.int size: The size of the collection in bytes.
        :param _builtins.str status: The status of the collection.
        :param _builtins.int vector_count: The number of records stored in the collection.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "vector_count", vector_count)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.int:
        """
        The dimension of the vectors stored in each record held in the collection.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment where the collection is hosted.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the collection.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the collection in bytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the collection.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="vectorCount")
    def vector_count(self) -> _builtins.int:
        """
        The number of records stored in the collection.
        """
        return pulumi.get(self, "vector_count")


@pulumi.output_type
class GetEmbedResult(dict):
    def __init__(__self__, *,
                 dimension: _builtins.int,
                 field_map: Mapping[str, _builtins.str],
                 metric: _builtins.str,
                 model: _builtins.str,
                 read_parameters: Mapping[str, _builtins.str],
                 vector_type: _builtins.str,
                 write_parameters: Mapping[str, _builtins.str]):
        """
        :param _builtins.int dimension: The dimension of the embedding model, specifying the size of the output vector.
        :param Mapping[str, _builtins.str] field_map: Identifies the name of the text field from your document model that will be embedded.
        :param _builtins.str metric: The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        :param _builtins.str model: the name of the embedding model to use for the index.
        :param Mapping[str, _builtins.str] read_parameters: The read parameters for the embedding model.
        :param _builtins.str vector_type: The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        :param Mapping[str, _builtins.str] write_parameters: The write parameters for the embedding model.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "field_map", field_map)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "read_parameters", read_parameters)
        pulumi.set(__self__, "vector_type", vector_type)
        pulumi.set(__self__, "write_parameters", write_parameters)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.int:
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="fieldMap")
    def field_map(self) -> Mapping[str, _builtins.str]:
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        return pulumi.get(self, "field_map")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        the name of the embedding model to use for the index.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="readParameters")
    def read_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The read parameters for the embedding model.
        """
        return pulumi.get(self, "read_parameters")

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> _builtins.str:
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        return pulumi.get(self, "vector_type")

    @_builtins.property
    @pulumi.getter(name="writeParameters")
    def write_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The write parameters for the embedding model.
        """
        return pulumi.get(self, "write_parameters")


@pulumi.output_type
class GetEsIndexResult(dict):
    def __init__(__self__, *,
                 deletion_protection: _builtins.str,
                 dimension: _builtins.int,
                 embed: 'outputs.GetEsIndexEmbedResult',
                 host: _builtins.str,
                 metric: _builtins.str,
                 name: _builtins.str,
                 spec: 'outputs.GetEsIndexSpecResult',
                 status: 'outputs.GetEsIndexStatusResult',
                 tags: Mapping[str, _builtins.str],
                 vector_type: _builtins.str):
        """
        :param _builtins.str deletion_protection: Index deletion protection configuration
        :param _builtins.int dimension: Index dimension
        :param 'GetEsIndexEmbedArgs' embed: Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
        :param _builtins.str host: The URL address where the index is hosted.
        :param _builtins.str metric: Index metric
        :param _builtins.str name: Index name
        :param 'GetEsIndexSpecArgs' spec: Spec
        :param 'GetEsIndexStatusArgs' status: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata_config is present, only specified metadata fields are indexed. To specify metadata fields to index, provide an array of the following form: [example_metadata_field]
        :param Mapping[str, _builtins.str] tags: Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
        :param _builtins.str vector_type: Index vector type
        """
        pulumi.set(__self__, "deletion_protection", deletion_protection)
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "embed", embed)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vector_type", vector_type)

    @_builtins.property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> _builtins.str:
        """
        Index deletion protection configuration
        """
        return pulumi.get(self, "deletion_protection")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.int:
        """
        Index dimension
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter
    def embed(self) -> 'outputs.GetEsIndexEmbedResult':
        """
        Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
        """
        return pulumi.get(self, "embed")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The URL address where the index is hosted.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        Index metric
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Index name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> 'outputs.GetEsIndexSpecResult':
        """
        Spec
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.GetEsIndexStatusResult':
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata_config is present, only specified metadata fields are indexed. To specify metadata fields to index, provide an array of the following form: [example_metadata_field]
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> _builtins.str:
        """
        Index vector type
        """
        return pulumi.get(self, "vector_type")


@pulumi.output_type
class GetEsIndexEmbedResult(dict):
    def __init__(__self__, *,
                 dimension: _builtins.int,
                 field_map: Mapping[str, _builtins.str],
                 metric: _builtins.str,
                 model: _builtins.str,
                 read_parameters: Mapping[str, _builtins.str],
                 vector_type: _builtins.str,
                 write_parameters: Mapping[str, _builtins.str]):
        """
        :param _builtins.int dimension: The dimension of the embedding model, specifying the size of the output vector.
        :param Mapping[str, _builtins.str] field_map: Identifies the name of the text field from your document model that will be embedded.
        :param _builtins.str metric: The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        :param _builtins.str model: the name of the embedding model to use for the index.
        :param Mapping[str, _builtins.str] read_parameters: The read parameters for the embedding model.
        :param _builtins.str vector_type: The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        :param Mapping[str, _builtins.str] write_parameters: The write parameters for the embedding model.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "field_map", field_map)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "read_parameters", read_parameters)
        pulumi.set(__self__, "vector_type", vector_type)
        pulumi.set(__self__, "write_parameters", write_parameters)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.int:
        """
        The dimension of the embedding model, specifying the size of the output vector.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter(name="fieldMap")
    def field_map(self) -> Mapping[str, _builtins.str]:
        """
        Identifies the name of the text field from your document model that will be embedded.
        """
        return pulumi.get(self, "field_map")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector*type' is 'sparse', the metric must be 'dotproduct'. If the vector*type is dense, the metric defaults to 'cosine'.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        the name of the embedding model to use for the index.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="readParameters")
    def read_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The read parameters for the embedding model.
        """
        return pulumi.get(self, "read_parameters")

    @_builtins.property
    @pulumi.getter(name="vectorType")
    def vector_type(self) -> _builtins.str:
        """
        The index vector type associated with the model. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension will be nil.
        """
        return pulumi.get(self, "vector_type")

    @_builtins.property
    @pulumi.getter(name="writeParameters")
    def write_parameters(self) -> Mapping[str, _builtins.str]:
        """
        The write parameters for the embedding model.
        """
        return pulumi.get(self, "write_parameters")


@pulumi.output_type
class GetEsIndexSpecResult(dict):
    def __init__(__self__, *,
                 pod: 'outputs.GetEsIndexSpecPodResult',
                 serverless: 'outputs.GetEsIndexSpecServerlessResult'):
        """
        :param 'GetEsIndexSpecPodArgs' pod: Configuration needed to deploy a pod-based index.
        :param 'GetEsIndexSpecServerlessArgs' serverless: Configuration needed to deploy a serverless index.
        """
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "serverless", serverless)

    @_builtins.property
    @pulumi.getter
    def pod(self) -> 'outputs.GetEsIndexSpecPodResult':
        """
        Configuration needed to deploy a pod-based index.
        """
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> 'outputs.GetEsIndexSpecServerlessResult':
        """
        Configuration needed to deploy a serverless index.
        """
        return pulumi.get(self, "serverless")


@pulumi.output_type
class GetEsIndexSpecPodResult(dict):
    def __init__(__self__, *,
                 environment: _builtins.str,
                 metadata_config: 'outputs.GetEsIndexSpecPodMetadataConfigResult',
                 pod_type: _builtins.str,
                 pods: _builtins.int,
                 replicas: _builtins.int,
                 shards: _builtins.int,
                 source_collection: _builtins.str):
        """
        :param _builtins.str environment: The environment where the index is hosted.
        :param 'GetEsIndexSpecPodMetadataConfigArgs' metadata_config: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        :param _builtins.str pod_type: The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        :param _builtins.int pods: The number of pods to be used in the index. This should be equal to shards x replicas.'
        :param _builtins.int replicas: The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        :param _builtins.int shards: The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        :param _builtins.str source_collection: The name of the collection to create an index from.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "metadata_config", metadata_config)
        pulumi.set(__self__, "pod_type", pod_type)
        pulumi.set(__self__, "pods", pods)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "shards", shards)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment where the index is hosted.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="metadataConfig")
    def metadata_config(self) -> 'outputs.GetEsIndexSpecPodMetadataConfigResult':
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        return pulumi.get(self, "metadata_config")

    @_builtins.property
    @pulumi.getter(name="podType")
    def pod_type(self) -> _builtins.str:
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        return pulumi.get(self, "pod_type")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> _builtins.int:
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def shards(self) -> _builtins.int:
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        return pulumi.get(self, "shards")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        """
        The name of the collection to create an index from.
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetEsIndexSpecPodMetadataConfigResult(dict):
    def __init__(__self__, *,
                 indexeds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] indexeds: The indexed fields.
        """
        pulumi.set(__self__, "indexeds", indexeds)

    @_builtins.property
    @pulumi.getter
    def indexeds(self) -> Sequence[_builtins.str]:
        """
        The indexed fields.
        """
        return pulumi.get(self, "indexeds")


@pulumi.output_type
class GetEsIndexSpecServerlessResult(dict):
    def __init__(__self__, *,
                 cloud: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud: Ready.
        :param _builtins.str region: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        """
        Ready.
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetEsIndexStatusResult(dict):
    def __init__(__self__, *,
                 ready: _builtins.bool,
                 state: _builtins.str):
        """
        :param _builtins.bool ready: Ready.
        :param _builtins.str state: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "ready", ready)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def ready(self) -> _builtins.bool:
        """
        Ready.
        """
        return pulumi.get(self, "ready")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetSpecResult(dict):
    def __init__(__self__, *,
                 pod: 'outputs.GetSpecPodResult',
                 serverless: 'outputs.GetSpecServerlessResult'):
        """
        :param 'GetSpecPodArgs' pod: Configuration needed to deploy a pod-based index.
        :param 'GetSpecServerlessArgs' serverless: Configuration needed to deploy a serverless index.
        """
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "serverless", serverless)

    @_builtins.property
    @pulumi.getter
    def pod(self) -> 'outputs.GetSpecPodResult':
        """
        Configuration needed to deploy a pod-based index.
        """
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> 'outputs.GetSpecServerlessResult':
        """
        Configuration needed to deploy a serverless index.
        """
        return pulumi.get(self, "serverless")


@pulumi.output_type
class GetSpecPodResult(dict):
    def __init__(__self__, *,
                 environment: _builtins.str,
                 metadata_config: 'outputs.GetSpecPodMetadataConfigResult',
                 pod_type: _builtins.str,
                 pods: _builtins.int,
                 replicas: _builtins.int,
                 shards: _builtins.int,
                 source_collection: _builtins.str):
        """
        :param _builtins.str environment: The environment where the index is hosted.
        :param 'GetSpecPodMetadataConfigArgs' metadata_config: Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        :param _builtins.str pod_type: The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        :param _builtins.int pods: The number of pods to be used in the index. This should be equal to shards x replicas.'
        :param _builtins.int replicas: The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        :param _builtins.int shards: The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        :param _builtins.str source_collection: The name of the collection to create an index from.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "metadata_config", metadata_config)
        pulumi.set(__self__, "pod_type", pod_type)
        pulumi.set(__self__, "pods", pods)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "shards", shards)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment where the index is hosted.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="metadataConfig")
    def metadata_config(self) -> 'outputs.GetSpecPodMetadataConfigResult':
        """
        Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when metadata*config is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
        """
        return pulumi.get(self, "metadata_config")

    @_builtins.property
    @pulumi.getter(name="podType")
    def pod_type(self) -> _builtins.str:
        """
        The type of pod to use. One of s1, p1, or p2 appended with . and one of x1, x2, x4, or x8.
        """
        return pulumi.get(self, "pod_type")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> _builtins.int:
        """
        The number of pods to be used in the index. This should be equal to shards x replicas.'
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def shards(self) -> _builtins.int:
        """
        The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
        """
        return pulumi.get(self, "shards")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        """
        The name of the collection to create an index from.
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSpecPodMetadataConfigResult(dict):
    def __init__(__self__, *,
                 indexeds: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] indexeds: The indexed fields.
        """
        pulumi.set(__self__, "indexeds", indexeds)

    @_builtins.property
    @pulumi.getter
    def indexeds(self) -> Sequence[_builtins.str]:
        """
        The indexed fields.
        """
        return pulumi.get(self, "indexeds")


@pulumi.output_type
class GetSpecServerlessResult(dict):
    def __init__(__self__, *,
                 cloud: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud: Ready.
        :param _builtins.str region: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        """
        Ready.
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStatusResult(dict):
    def __init__(__self__, *,
                 ready: _builtins.bool,
                 state: _builtins.str):
        """
        :param _builtins.bool ready: Ready.
        :param _builtins.str state: Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        pulumi.set(__self__, "ready", ready)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def ready(self) -> _builtins.bool:
        """
        Ready.
        """
        return pulumi.get(self, "ready")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Initializing InitializationFailed ScalingUp ScalingDown ScalingUpPodSize ScalingDownPodSize Upgrading Terminating Ready
        """
        return pulumi.get(self, "state")


