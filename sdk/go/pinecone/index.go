// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pinecone

import (
	"context"
	"reflect"

	"github.com/pinecone-io/pulumi-pinecone/sdk/v2/go/pinecone/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `Index` resource lets you create and manage indexes in Pinecone. Learn more about indexes in the [docs](https://docs.pinecone.io/guides/indexes/understanding-indexes).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-terraform-provider/sdks/go/pinecone/v2/pinecone"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := pinecone.NewIndex(ctx, "test", &pinecone.IndexArgs{
//				Name:      pulumi.String("tftestindex"),
//				Dimension: pulumi.Float64(10),
//				Spec: &pinecone.IndexSpecArgs{
//					Serverless: &pinecone.IndexSpecServerlessArgs{
//						Cloud:  pulumi.String("aws"),
//						Region: pulumi.String("us-west-2"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Index struct {
	pulumi.CustomResourceState

	// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
	DeletionProtection pulumi.StringOutput `pulumi:"deletionProtection"`
	// The dimensions of the vectors to be inserted in the index
	Dimension pulumi.IntOutput `pulumi:"dimension"`
	// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
	Embed IndexEmbedOutput `pulumi:"embed"`
	// The URL address where the index is hosted.
	Host pulumi.StringOutput `pulumi:"host"`
	// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
	Metric pulumi.StringOutput `pulumi:"metric"`
	// The name of the index to be created. The maximum length is 45 characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// Spec
	Spec IndexSpecPtrOutput `pulumi:"spec"`
	// Status
	Status IndexStatusOutput `pulumi:"status"`
	// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags     pulumi.StringMapOutput `pulumi:"tags"`
	Timeouts IndexTimeoutsPtrOutput `pulumi:"timeouts"`
	// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
	VectorType pulumi.StringOutput `pulumi:"vectorType"`
}

// NewIndex registers a new resource with the given unique name, arguments, and options.
func NewIndex(ctx *pulumi.Context,
	name string, args *IndexArgs, opts ...pulumi.ResourceOption) (*Index, error) {
	if args == nil {
		args = &IndexArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Index
	err := ctx.RegisterResource("pinecone:index/index:Index", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIndex gets an existing Index resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIndex(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IndexState, opts ...pulumi.ResourceOption) (*Index, error) {
	var resource Index
	err := ctx.ReadResource("pinecone:index/index:Index", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Index resources.
type indexState struct {
	// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
	DeletionProtection *string `pulumi:"deletionProtection"`
	// The dimensions of the vectors to be inserted in the index
	Dimension *int `pulumi:"dimension"`
	// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
	Embed *IndexEmbed `pulumi:"embed"`
	// The URL address where the index is hosted.
	Host *string `pulumi:"host"`
	// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
	Metric *string `pulumi:"metric"`
	// The name of the index to be created. The maximum length is 45 characters.
	Name *string `pulumi:"name"`
	// Spec
	Spec *IndexSpec `pulumi:"spec"`
	// Status
	Status *IndexStatus `pulumi:"status"`
	// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags     map[string]string `pulumi:"tags"`
	Timeouts *IndexTimeouts    `pulumi:"timeouts"`
	// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
	VectorType *string `pulumi:"vectorType"`
}

type IndexState struct {
	// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
	DeletionProtection pulumi.StringPtrInput
	// The dimensions of the vectors to be inserted in the index
	Dimension pulumi.IntPtrInput
	// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
	Embed IndexEmbedPtrInput
	// The URL address where the index is hosted.
	Host pulumi.StringPtrInput
	// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
	Metric pulumi.StringPtrInput
	// The name of the index to be created. The maximum length is 45 characters.
	Name pulumi.StringPtrInput
	// Spec
	Spec IndexSpecPtrInput
	// Status
	Status IndexStatusPtrInput
	// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags     pulumi.StringMapInput
	Timeouts IndexTimeoutsPtrInput
	// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
	VectorType pulumi.StringPtrInput
}

func (IndexState) ElementType() reflect.Type {
	return reflect.TypeOf((*indexState)(nil)).Elem()
}

type indexArgs struct {
	// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
	DeletionProtection *string `pulumi:"deletionProtection"`
	// The dimensions of the vectors to be inserted in the index
	Dimension *int `pulumi:"dimension"`
	// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
	Embed *IndexEmbed `pulumi:"embed"`
	// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
	Metric *string `pulumi:"metric"`
	// The name of the index to be created. The maximum length is 45 characters.
	Name *string `pulumi:"name"`
	// Spec
	Spec *IndexSpec `pulumi:"spec"`
	// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags     map[string]string `pulumi:"tags"`
	Timeouts *IndexTimeouts    `pulumi:"timeouts"`
	// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
	VectorType *string `pulumi:"vectorType"`
}

// The set of arguments for constructing a Index resource.
type IndexArgs struct {
	// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
	DeletionProtection pulumi.StringPtrInput
	// The dimensions of the vectors to be inserted in the index
	Dimension pulumi.IntPtrInput
	// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
	Embed IndexEmbedPtrInput
	// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
	Metric pulumi.StringPtrInput
	// The name of the index to be created. The maximum length is 45 characters.
	Name pulumi.StringPtrInput
	// Spec
	Spec IndexSpecPtrInput
	// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '', or '-'. Values must be alphanumeric, ';', '@', '', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags     pulumi.StringMapInput
	Timeouts IndexTimeoutsPtrInput
	// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
	VectorType pulumi.StringPtrInput
}

func (IndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*indexArgs)(nil)).Elem()
}

type IndexInput interface {
	pulumi.Input

	ToIndexOutput() IndexOutput
	ToIndexOutputWithContext(ctx context.Context) IndexOutput
}

func (*Index) ElementType() reflect.Type {
	return reflect.TypeOf((**Index)(nil)).Elem()
}

func (i *Index) ToIndexOutput() IndexOutput {
	return i.ToIndexOutputWithContext(context.Background())
}

func (i *Index) ToIndexOutputWithContext(ctx context.Context) IndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexOutput)
}

// IndexArrayInput is an input type that accepts IndexArray and IndexArrayOutput values.
// You can construct a concrete instance of `IndexArrayInput` via:
//
//	IndexArray{ IndexArgs{...} }
type IndexArrayInput interface {
	pulumi.Input

	ToIndexArrayOutput() IndexArrayOutput
	ToIndexArrayOutputWithContext(context.Context) IndexArrayOutput
}

type IndexArray []IndexInput

func (IndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Index)(nil)).Elem()
}

func (i IndexArray) ToIndexArrayOutput() IndexArrayOutput {
	return i.ToIndexArrayOutputWithContext(context.Background())
}

func (i IndexArray) ToIndexArrayOutputWithContext(ctx context.Context) IndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexArrayOutput)
}

// IndexMapInput is an input type that accepts IndexMap and IndexMapOutput values.
// You can construct a concrete instance of `IndexMapInput` via:
//
//	IndexMap{ "key": IndexArgs{...} }
type IndexMapInput interface {
	pulumi.Input

	ToIndexMapOutput() IndexMapOutput
	ToIndexMapOutputWithContext(context.Context) IndexMapOutput
}

type IndexMap map[string]IndexInput

func (IndexMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Index)(nil)).Elem()
}

func (i IndexMap) ToIndexMapOutput() IndexMapOutput {
	return i.ToIndexMapOutputWithContext(context.Background())
}

func (i IndexMap) ToIndexMapOutputWithContext(ctx context.Context) IndexMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexMapOutput)
}

type IndexOutput struct{ *pulumi.OutputState }

func (IndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Index)(nil)).Elem()
}

func (o IndexOutput) ToIndexOutput() IndexOutput {
	return o
}

func (o IndexOutput) ToIndexOutputWithContext(ctx context.Context) IndexOutput {
	return o
}

// Whether deletion protection for the index is enabled. You can use 'enabled', or 'disabled'.
func (o IndexOutput) DeletionProtection() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.DeletionProtection }).(pulumi.StringOutput)
}

// The dimensions of the vectors to be inserted in the index
func (o IndexOutput) Dimension() pulumi.IntOutput {
	return o.ApplyT(func(v *Index) pulumi.IntOutput { return v.Dimension }).(pulumi.IntOutput)
}

// Specify the integrated inference embedding configuration for the index. Once set, the model cannot be changed. However, you can later update the embedding configuration—including field map, read parameters, and write parameters.
func (o IndexOutput) Embed() IndexEmbedOutput {
	return o.ApplyT(func(v *Index) IndexEmbedOutput { return v.Embed }).(IndexEmbedOutput)
}

// The URL address where the index is hosted.
func (o IndexOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.Host }).(pulumi.StringOutput)
}

// The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the vectorType is dense, the metric defaults to 'cosine'.
func (o IndexOutput) Metric() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.Metric }).(pulumi.StringOutput)
}

// The name of the index to be created. The maximum length is 45 characters.
func (o IndexOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Spec
func (o IndexOutput) Spec() IndexSpecPtrOutput {
	return o.ApplyT(func(v *Index) IndexSpecPtrOutput { return v.Spec }).(IndexSpecPtrOutput)
}

// Status
func (o IndexOutput) Status() IndexStatusOutput {
	return o.ApplyT(func(v *Index) IndexStatusOutput { return v.Status }).(IndexStatusOutput)
}

// Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, ”, or '-'. Values must be alphanumeric, ';', '@', ”, '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
func (o IndexOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Index) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o IndexOutput) Timeouts() IndexTimeoutsPtrOutput {
	return o.ApplyT(func(v *Index) IndexTimeoutsPtrOutput { return v.Timeouts }).(IndexTimeoutsPtrOutput)
}

// The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified. If 'sparse', the vector dimension should not be specified.
func (o IndexOutput) VectorType() pulumi.StringOutput {
	return o.ApplyT(func(v *Index) pulumi.StringOutput { return v.VectorType }).(pulumi.StringOutput)
}

type IndexArrayOutput struct{ *pulumi.OutputState }

func (IndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Index)(nil)).Elem()
}

func (o IndexArrayOutput) ToIndexArrayOutput() IndexArrayOutput {
	return o
}

func (o IndexArrayOutput) ToIndexArrayOutputWithContext(ctx context.Context) IndexArrayOutput {
	return o
}

func (o IndexArrayOutput) Index(i pulumi.IntInput) IndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Index {
		return vs[0].([]*Index)[vs[1].(int)]
	}).(IndexOutput)
}

type IndexMapOutput struct{ *pulumi.OutputState }

func (IndexMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Index)(nil)).Elem()
}

func (o IndexMapOutput) ToIndexMapOutput() IndexMapOutput {
	return o
}

func (o IndexMapOutput) ToIndexMapOutputWithContext(ctx context.Context) IndexMapOutput {
	return o
}

func (o IndexMapOutput) MapIndex(k pulumi.StringInput) IndexOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Index {
		return vs[0].(map[string]*Index)[vs[1].(string)]
	}).(IndexOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IndexInput)(nil)).Elem(), &Index{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexArrayInput)(nil)).Elem(), IndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexMapInput)(nil)).Elem(), IndexMap{})
	pulumi.RegisterOutputType(IndexOutput{})
	pulumi.RegisterOutputType(IndexArrayOutput{})
	pulumi.RegisterOutputType(IndexMapOutput{})
}
